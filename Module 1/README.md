# Module 1 - Classical Compilation

Module 1 walks through the classical computer compilation process and demonstrates how high-level programming languages (in particular C/C++, Rust, Julia, and Python) can be translated into LLVM intermediate representation (IR). We give a series of tutorials:

1. `1_Simple_Function` walks through the frontend of the compilation process, starting from a simple function and ending with the LLVM IR generated by it.
2. In the `More_Examples` directory, we have `2_Newton_Raphson`, which takes a more in depth look at how IR expresses high-level constructs such as conditionals, loops, and function calls.
3. Also in `More_Examples`, `3_Object_Oriented_Example` demonstrates the ability of IR to strip layers of abstraction such as classes and methods and express them at a low level.

## Intermediate Representation - What is it?

Any compilers goal, at the most basic level, is to take a program written in a "source" language A (often a high-level language, such as C/C++ or Javascript) and translate it into a "target" language B (often code which is executable by a computer, and completely non-readable for humans).

Intermediate Representation (IR) is a representation compilers often use between the source and target languages. IR can be thought of as the data structure used by compilers or virtual machines to represent source code. There are many forms of IR - in fact, compilation can be thought of as a series of steps which translate from one form of IR to another.

The benefits of IR are that it:
- Provides a customary platform to share across targets and sources and allows re-use in compiler machinery.
- Allows for efficient code transformation, analysis, and optimization, regardless of the original language it was written in.
- Can express high level constructs in low level expressions which are human-readable while also giving a clear idea of how a machine would actually go about executing a code snippet.

In this module, we are most interested in LLVM IR, a standard form which nearly all compilers and languages have support for. It is part of the widely used [LLVM compiler toolchain](https://llvm.org/). 

The primary purpose of the LLVM IR is to be interoperable with all other languages as well as any architectural backends. We chose these high-level languages because they are prevalent in the quantum computing industry space. On the other hand, due to the interoperable nature of LLVM, we can widen the scope of these examples with nearly any given programming languages.

## Compilation Frontend

Drawing on the notorious "Dragon Book", any compiler has some general steps or "phases" which allow translation from source to target. They can be broadly grouped into _analysis_, known as the frontend of a compiler, and _synthesis_, or the backend. Analysis extracts meaningful metadata and imposes structure on input code in such a way that a compiler "back-end" can use the information gathered in order to output an equivalent program written in the target language. We will trace compilation steps only up to the generation of IR, which corresponds to only the frontend or analysis phase.

These are:

### Lexical (Scanning) Analysis

Lexical analysis is the first phase of the compiler. It reads the input code as a raw character stream and creates meaningful sequences, called _tokens_ or _lexemes_. Its output is a token stream, which is used in the next step...

### Syntax (Parsing) Analysis

Syntax analysis makes a tree-like IR known as an _Abstract Syntax Tree_ (AST) from the tokens it receives. It imposes structure on these tokens according to the _grammar_, or linguistic rules and formulations, allowed by the source language, and ensures it is syntactically sound. The AST is utilized in...

### Semantic (Syntax tree) Analysis

This part of the analysis uses the previous step's syntax tree information to gather all the information helpful during IR generation. Rather than grammatical structure, it is concerned with the actual content (semantics) of the code. Finally, analysis wraps up and synthesis can be said to begin with...

### Intermediate Code Generator (IR representation)

Before translating into the final target language, compilers will generate a low-level machine-like IR, such as LLVM IR. This IR is then used in several synthesis steps such as:

+ Machine-Independent Code Optimization (IR representation)
+ Code Generation (target-machine code)
+ Machine-Dependent Code Optimization (target-machine code)

Our goal in Module 1 is to use different high-level languages and create exactly equivalent LLVM IR representations, while providing insight into how this is reached. Each high-level language has a tutorial for reaching the intermediate representation, and we will see more specific explanations of each compilation step with related programming languages.
